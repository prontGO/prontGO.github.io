
[{"content":"","date":"2025年8月10日","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","date":"2025年8月10日","externalUrl":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","date":"2025年8月10日","externalUrl":null,"permalink":"/","section":"Pront Change Log","summary":"","title":"Pront Change Log","type":"page"},{"content":"","date":"2025年8月10日","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":" 在做網頁時，常常不知道該用哪種載入畫面，或是根本不清楚怎麼實作。\n本文將整理幾種常見的載入動畫，並分析它們的優缺點，讓你方便在網頁中運用。\n旋轉載入動畫（Spinner） # 這應該是最常見的載入畫面了，在很多地方都適用，也不會過度花俏。\n其實光旋轉載入動畫就有很多種類型，接下來我來介紹幾種常見的旋轉動畫。\n如果想要讓你的載入動畫顯示在頁面的最上方，可以使用這樣的CSS：\n.container { /*設定高度、位置*/ position: fixed; top: 0; left: 0; height: 100vh; width: 100vw; z-index: 1000; /*置中*/ display: flex; align-items: center; justify-content: center; /*設定背景黑色*/ background-color: rgba(0, 0, 0, 0.5); } 然後在套用container的class到你要的元件上就好了：\nSee the Pen 固定在最上方的Spinner by Pront (@Pront-lin) on CodePen. 旋轉載入器（簡單） # 這是最簡單的載入動畫了，只需要幫一個圓形套用旋轉動畫就好了。\nSee the Pen 旋轉加載器 by Pront (@Pront-lin) on CodePen. 首先先畫一個圓形：\n.spinner { /* 確保不會自動換行 */ display: inline-block; /* 設定大小 */ min-width: 100px; min-height: 100px; /* border設定1/4藍色 */ border: 10px solid #c4dfff; border-top-color: #639dff; /* 設定圓形 */ border-radius: 50%; } 然後再套入旋轉動畫：\n.spinner { /* 確保不會自動換行 */ display: inline-block; /* 設定大小 */ min-width: 100px; min-height: 100px; /* border設定1/4籃色 */ border: 10px solid #c4dfff; border-top-color: #639dff; /* 設定圓形 */ border-radius: 50%; animation: spin 1s linear infinite; } @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } } 就可以直接在html套用了：\n\u0026lt;div class=\u0026#34;spinner\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; 這個動畫的優點就是製作超簡單，效果也不錯，不過比較單調一點。\n旋轉載入器（進階） # 這是一個符合Google Material Design 的Loading載入器（如果自己懶的寫程式，也可以直接使用Material Web程式庫 ），這很常可以在Chrome、Youtube以及一些手機軟體中看到，是一個比較進階的旋轉載入器。\nSee the Pen indeterminate spinner by Pront (@Pront-lin) on CodePen. 首先，要先用SVG定義一個圓形：\n\u0026lt;svg class=\u0026#34;svg-spinner\u0026#34; viewBox=\u0026#34;0 0 100 100\u0026#34;\u0026gt; \u0026lt;circle class=\u0026#34;spinner-path\u0026#34; cx=\u0026#34;50\u0026#34; cy=\u0026#34;50\u0026#34; r=\u0026#34;40\u0026#34; fill=\u0026#34;none\u0026#34; stroke-width=\u0026#34;6\u0026#34; stroke=\u0026#34;#3f51b5\u0026#34; stroke-linecap=\u0026#34;round\u0026#34;/\u0026gt; \u0026lt;/svg\u0026gt; svg的viewBox代表範圍（從(0,0)開始，寬跟高100，單位是座標） circle代表圓形，cx跟cy代表x座標跟y座標 fill代表是否填充（在這裡是空心載入器，所以為none） r代表圓半徑（單位是座標） stroke-width代表厚度（單位是座標） stroke代表圖形顏色 stroke-linecap代表線條端點的形狀（這裡設定為圓角） 這時畫面應該會有一個中空的藍色圓形。\n現在可以設定spinner的高跟寬（設定多少都可以）：\n.svg-spinner { width: 100px; height: 100px; } 這時就能加入spin動畫了：\n.svg-spinner { width: 100px; height: 100px; animation: spin 1.4s linear infinite; } @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } } 當然，你現在應該看不到任何的選轉效果，應為目前它只是一個完整的圓（如果不信，可以用檢查功能來看圓是不是真的在轉）。\n接下來來到重點了，為了要讓圖形可以伸長又縮短，要使用 stroke-dasharray 來處理伸縮，以及使用 stroke-dashoffset來移動位置。\n先算出圓週長：\n$$ 40 \\times 2 \\times \\pi \\approx 251.3 $$\n這裡的「40」就是在circle裡面所設定的r（半徑）。\n加入伸縮動畫：\n.spinner-path { /* 套用動畫 */ animation: dash 1.4s ease-in-out infinite; } @keyframes dash { 0% { /* 先從1 + 251個空格開始（一個點） */ stroke-dasharray: 1, 251; stroke-dashoffset: 0; } 50% { /* 變成125 + 251個空格（1/4圓，超出的空格會被忽略） */ stroke-dasharray: 125, 251; /* 空格的開始點往左偏移1/4圓 */ stroke-dashoffset: -62.8; } 100% { /* 回到原本狀態 */ stroke-dasharray: 1, 251; /* 偏移251（回原點）*/ stroke-dashoffset: -251; } } 這裡的stroke-dasharray都是在調整圓的邊顯示多少，第一個數值代表顯示的週長，第二個數值代表隱藏的週長。 這裡的stroke-dashoffset是指說「線的起點偏移」，所以當整個SVG往右時，整個圓形就會往左（因為起點往左偏移），並且拉長。讓圖形看起來像在往右滑動。 這樣就完成了這個動畫了，這個動化的優點就是看起來不會像前一個一樣太單調，而且這個動畫也很常見，唯一的缺點就是第一次製作時要花比較久時間（當然使用別人寫好的程式庫可以快很多 ）。\n進度條（Progress Bar） # 有時候做網頁時會需要用到進度條，我這裡要講的進度條不是Windows那種安裝軟體時的進度條，而是切換畫面或是載入東西時的進度條，通常出現在網頁最上方。\n固定進度條 # 固定進度條是指說可以用腳本控制進度，而不是像非恆定進度條一樣都不會顯示已經載入到哪裡了，這樣的好處是讓使用者知道加載多少了（不過其實很多進度條都只是假的，都只是給使用者看開心的）。\nSee the Pen 固定進度條 by Pront (@Pront-lin) on CodePen. （長的很像Youtube的載入條）\n這個進度條的重點是在JavaScript。\n首先，增加一個進度條：\n\u0026lt;div class=\u0026#34;progress-bar\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; 並且讓進度條置頂：\n.progress-bar { /* 置頂 */ position: absolute; top: 0; left: 0; width: 100%; height: 3px; background-color: red; /* 動畫設定（預設隱藏） */ transform: scalex(0); transform-origin: left; } 為了方便測試，我有寫一個測試用的等待函式（等待1.5到2.5秒）：\nfunction load() { return new Promise((resolve) =\u0026gt; { setTimeout(() =\u0026gt; { resolve() }, (Math.random() + 1.5) * 1000) }) } 先設定2.5秒內到達進度90%：\nfunction handleLoad() { bar.style.transition = \u0026#34;transform 2.5s ease-out\u0026#34; bar.style.transform = \u0026#34;scaleX(0.9)\u0026#34; /* 強制刷新 */ bar.offsetHeight } 如果等到加載成功了就直接讓進度條跑完：\nfunction handleLoad() { load().then(() =\u0026gt; { bar.style.transition = \u0026#34;transform 0.3s ease-in\u0026#34; bar.style.transform = \u0026#34;scaleX(1)\u0026#34; /* 強制刷新 */ bar.offsetHeight }) bar.style.transition = \u0026#34;transform 2.5s ease-out\u0026#34; bar.style.transform = \u0026#34;scaleX(0.9)\u0026#34; /* 強制刷新 */ bar.offsetHeight } 最後在設定跑完之後隱藏progress bar：\nfunction handleLoad() { const bar = document.querySelector(\u0026#34;.progress-bar\u0026#34;) load().then(() =\u0026gt; { bar.style.transition = \u0026#34;transform 0.3s ease-in\u0026#34; bar.style.transform = \u0026#34;scaleX(1)\u0026#34; bar.offsetHeight setTimeout(() =\u0026gt; { bar.style.transition = \u0026#34;none\u0026#34; bar.style.transform = \u0026#34;scaleX(0)\u0026#34; bar.offsetHeight }, (1600)) }) bar.style.transition = \u0026#34;transform 2.5s ease-out\u0026#34; bar.style.transform = \u0026#34;scaleX(0.9)\u0026#34; bar.offsetHeight } 這樣就完成這個動畫了，這個動畫的優點是切換畫面時很常見，缺點就是可能會卡在90%（如果伺服器一直不回應）。\n非恆定進度條 # 如果有一個東西跑很久，或是說不知道要執行多久，就可以使用「非恆定進度條」，也就是一直在跑的進度條。\nSee the Pen 非恆定進度條 by Pront (@Pront-lin) on CodePen. 首先，先建立一個progress bar：\n\u0026lt;div class=\u0026#34;progress-bar-container\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;progress-bar\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; 接著讓container有淺灰色的背景：\n.progress-bar-container { width: 100%; height: 4px; background: #eee; } 然後要讓progress bar對齊上方：\n.progress-bar-container { width: 100%; height: 4px; background: #eee; /* 讓子元素可以使用父元素作為參考點 */ position: relative; /* 防止overflow */ overflow: hidden; } .progress-bar { /* 對齊上方 */ position: absolute; top: 0; /* 設定大小（高比父容器少1px）*/ width: 50%; height: 3px; } 最後再使用子元素的left來做動畫就可以了：\n.progress-bar { position: absolute; top: 0; width: 50%; height: 3px; background-color: red; /* 設定動畫 */ animation-duration: 1.5s; animation-name: progress-bar; animation-iteration-count: infinite; animation-timing-function: ease-out; } @keyframes progress-bar { 0% { left: -50%; } 100% { left: 100%; } } 這個動畫其實也是很常見，而且也不用擔心如何計算載入的百分比，而且比前一個簡單一點（不需要JavaScript）。\n骨架載入畫面（Skeleton Screen） # 骨架載入畫面是用來當網頁還在載入時先顯示布局的動畫，建議要在3秒以內載入完成，否則可能會影響使用者體驗。\nSee the Pen 骨架載入畫面 by Pront (@Pront-lin) on CodePen. 如果覺的螢幕太小可以到CodePen上觀看 第一步就是要設定好Skeleton的布局，像是範例中的布局就是一張圖片、一個標題、三行字：\n\u0026lt;div class=\u0026#34;skeleton-container\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;skeleton image-skeleton\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;skeleton title-skeleton\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;skeleton text-skeleton\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;skeleton text-skeleton\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;skeleton text-skeleton\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; 然後自行加上高度跟寬度：\n.image-skeleton { width: 500px; height: 300px; } .title-skeleton { margin: 25px 0; height: 50px; width: 350px; } .text-skeleton { margin: 15px 0; height: 30px; width: 450px; } 然後幫skeleton套上背景：\n.skeleton { /* 漸層效果，淺灰色0%~25% -\u0026gt; 除漸變成更淺的灰色25%~50% -\u0026gt; 逐漸回到回到淺灰色50%~70% -\u0026gt; 繼續維持淺灰色（剩下未設定）70%~100% */ background: linear-gradient(90deg, #e0e0e0 25%, #ececec 50%, #e0e0e0 75%); /*讓背景的大小成為原本的4背*/ background-size: 400% 100%; /*圓角（可選）*/ border-radius: 10px; } 最後套上動畫：\n.skeleton { background: linear-gradient(90deg, #e0e0e0 25%, #ececec 50%, #e0e0e0 75%); background-size: 400% 100%; border-radius: 10px; animation-name: shimmer; animation-duration: 2s; animation-iteration-count: infinite; animation-timing-function: linear; } @keyframes shimmer { /* 先從150%到-150%（加起來要400%）*/ 0% { background-position: 150% 0; } 100% { background-position: -150% 0; } } 這樣就做完了骨架動畫了，其實有時候也不一定要到套上動畫，就單純的灰色也很常見（Youtube首頁就是這樣），這應該是這裡面中最酷的動畫了。\n結論 # 有時候載入畫面其實根本不需要靠外部的庫，自己寫也能做到80分像了，不過如果本身用的程式庫就有包括載入畫面，那當然直接用會更快。\n這些的載入畫面我都研究了很久，像是第二個旋轉載入器，我是叫AI生成程式，結果我連svg標籤都看不懂在寫什麼，最後問AI很久，才終於理解（所以你看不懂我寫的也很正常）。\n","date":"2025年8月10日","externalUrl":null,"permalink":"/posts/loading-page-for-web/","section":"Posts","summary":"","title":"如何製作各種網頁載入畫面","type":"posts"},{"content":"","date":"2025年8月10日","externalUrl":null,"permalink":"/tags/%E7%A8%8B%E5%BC%8F%E8%A8%AD%E8%A8%88/","section":"Tags","summary":"","title":"程式設計","type":"tags"},{"content":"","date":"2025年8月10日","externalUrl":null,"permalink":"/tags/%E8%BC%89%E5%85%A5%E7%95%AB%E9%9D%A2/","section":"Tags","summary":"","title":"載入畫面","type":"tags"},{"content":"","date":"2025年8月10日","externalUrl":null,"permalink":"/categories/%E7%B6%B2%E9%A0%81%E9%96%8B%E7%99%BC/","section":"Categories","summary":"","title":"網頁開發","type":"categories"},{"content":"","date":"2025年8月10日","externalUrl":null,"permalink":"/tags/%E7%B6%B2%E9%A0%81%E9%96%8B%E7%99%BC/","section":"Tags","summary":"","title":"網頁開發","type":"tags"},{"content":"","date":"2025年4月19日","externalUrl":null,"permalink":"/tags/git/","section":"Tags","summary":"","title":"Git","type":"tags"},{"content":"","date":"2025年4月19日","externalUrl":null,"permalink":"/tags/github/","section":"Tags","summary":"","title":"GitHub","type":"tags"},{"content":"今天你可能想要push或clone你的GitHub儲存庫時，你可能會看到git要驗證你的身份：\nUsername for \u0026#39;https://github.com\u0026#39;: Password for \u0026#39;https://name@github.com\u0026#39;: 然後你輸入了帳號跟密碼：\nremote: Support for password authentication was removed on August 13, 2021. remote: Please see https://docs.github.com/get-started/getting-started-with-git/about-remote-repositories#cloning-with-https-urls for information on currently recommended modes of authentication. fatal: Authentication failed for \u0026#39;https://github.com/test/test.git/\u0026#39; 卻看到，它寫著Support for password authentication was removed on August 13, 2021.，也就是說這個登入方式早在2021/8/13就被停用了！\n本篇文章就是要來紀錄要如何正確連結GitHub。\n確認連結方式 # GitHub儲存庫有兩種連接方式，一個是HTTPS（預設）一個是SSH，可以在連結儲存庫時設定。 在GitHub上可以選擇使用HTTPS或SSH進行連線 可以用git remote指令來查看所有遠端儲存庫：\ngit remote -v 會輸出類似像這樣的結果：\norigin\thttps://github.com/timtimtim12754/calculator.git (fetch) origin\thttps://github.com/timtimtim12754/calculator.git (push) 這裡顯示HTTPS://代表是用HTTPS，如果是用SSH則會顯示類似這樣的結果：\norigin\tgit@github.com:timtimtim12754/calculator.git (fetch) origin\tgit@github.com:timtimtim12754/calculator.git (push) 用SSH連線就會用git@github.com作為開頭。\nSSH 或 HTTPS # 現在你已經知道了連結儲存庫有兩種連線方式，那要使用那一個呢？\n首先來比較一下SSH跟HTTPS\nHTTPS\n優點：\n簡單設定，登入帳號即可 缺點：\n安全性較低 切換身份較複雜 要額外安裝GitHub CLI作為驗證 SSH\n優點：\n安全性高 可輕鬆切換身份 缺點：\n初次使用要設定SSH Key，較麻煩 Windows可能要額外安裝軟體 比較完之後可以發現SSH連線方式比較具有優勢，頂多就只是首次要做比較多設定，所以除非你只是暫時clone一下東西，不然建議使用SSH連線方式。\n接下來我會來講解如何對於HTTPS或SSH的連線方式來驗證身份。\n使用HTTPS # 要用HTTPS連線情況下，直接輸入密碼的功能已經在2021年8月就停止支援了，所以你必須安裝GitHub CLI來驗證身份。\n首先，先到GitHub CLI的網站下載安裝。\n安裝完之後輸入以下指令：\ngh auth login 然後它會問你一些問題，你就選HTTPS登入，然後記得複製代碼就好了\n? Where do you use GitHub? GitHub.com ? What is your preferred protocol for Git operations on this host? HTTPS ? Authenticate Git with your GitHub credentials? Yes ? How would you like to authenticate GitHub CLI? Login with a web browser ! First copy your one-time code: 947C-2B46 #代碼 Press Enter to open https://github.com/login/device in your browser... Opening in existing browser session. 打開裝置登入畫面後登入你的帳號後再輸入代碼就行了 登入你的帳號後輸入代碼 這樣就能成功進行push操作了\nEnumerating objects: 4, done. Counting objects: 100% (4/4), done. Delta compression using up to 20 threads Compressing objects: 100% (3/3), done. Writing objects: 100% (3/3), 347 bytes | 347.00 KiB/s, done. Total 3 (delta 1), reused 0 (delta 0), pack-reused 0 remote: Resolving deltas: 100% (1/1), completed with 1 local object. To https://github.com/timtimtim12754/calculator.git 620b31c..5d3e57f main -\u0026gt; main 使用SSH # 要使用SSH連線首先你必須要有一個SSH Key，以下指令會生成分成公鑰跟私鑰：\nssh-keygen -t ed25519 -C \u0026#34;your_email@example.com\u0026#34; 它會先問你要Key儲存在哪裡，按下空白代表預設，密碼可以設定或是空白無密碼（直接Enter）。\nGenerating public/private ed25519 key pair. Enter file in which to save the key (/home/test/.ssh/id_ed25519): Enter passphrase (empty for no passphrase): Enter same passphrase again: Your identification has been saved in /home/test/.ssh/id_ed25519 Your public key has been saved in /home/test/.ssh/id_ed25519.pub The key fingerprint is: SHA256:i4QOg2BXp7GdnQG7A1keXuKZNqDjJ5G+P9Mn+PbUlsk test@example.com The key\u0026#39;s randomart image is: +--[ED25519 256]--+ | + *.o | | + \u0026amp; X o | |.. * = % o | |o.+ o.o o | |. o+...oS | | ++. ...o o | | .. + .. E | | .+ +... | | .=.+. | +----[SHA256]-----+ 然後你必須複製你SSH Key的公鑰（驗證身份），Key會儲存在~/.ssh資料夾，例如剛剛輸出結果中有顯示公鑰在/home/test/.ssh/id_ed25519.pub，這時把裡面的東西複製出來。\n例如我的公鑰是：\nssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIEQmOy7OWP4nAYePVTMDaos3M77W1Zkb3SgsUj4K4ywB test@example.com 然後把它複製到GitHub新增SSH Key區，然後按下儲存。 點選頭像 -\u0026gt; Settings -\u0026gt; SSH and GPG 打開設定SSH Key 接下來應該就能正常push跟pull了\n結論 # HTTPS要安裝GitHub CLI，SSH需要生成並添加公鑰，整體時間其實是差不多。\n所以還是建議使用SSH連線方式，不僅安全性高，還可以讓後續操作更為方便。\n","date":"2025年4月19日","externalUrl":null,"permalink":"/posts/git-connect-github/","section":"Posts","summary":"","title":"Git如何連結GitHub","type":"posts"},{"content":"","date":"2025年4月19日","externalUrl":null,"permalink":"/categories/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/","section":"Categories","summary":"","title":"版本控制","type":"categories"},{"content":"","date":"2025年4月19日","externalUrl":null,"permalink":"/tags/%E7%A8%8B%E5%BC%8F/","section":"Tags","summary":"","title":"程式","type":"tags"},{"content":" 前言 # Pront Change Log 啟動！\n","date":"2024年12月24日","externalUrl":null,"permalink":"/posts/startprontchangelog/","section":"Posts","summary":"Pront Change Log 啟動！","title":"Pront Change Log 啟動！","type":"posts"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"使用 Google 搜尋\n","externalUrl":null,"permalink":"/search/","section":"Pront Change Log","summary":"","title":"搜尋","type":"page"}]